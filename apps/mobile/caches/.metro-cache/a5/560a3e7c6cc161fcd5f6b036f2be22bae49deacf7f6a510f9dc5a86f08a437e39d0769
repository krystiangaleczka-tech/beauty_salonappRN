{"dependencies":[{"name":"@motionone/utils","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":1,"column":0,"index":0},"end":{"line":1,"column":46,"index":46}}],"key":"+655Tbr0Dg/RFFwL7HMoKgGI11s=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  Object.defineProperty(exports, \"cubicBezier\", {\n    enumerable: true,\n    get: function () {\n      return cubicBezier;\n    }\n  });\n  var _motiononeUtils = require(_dependencyMap[0], \"@motionone/utils\");\n  /*\n    Bezier function generator\n  \n    This has been modified from GaÃ«tan Renaudeau's BezierEasing\n    https://github.com/gre/bezier-easing/blob/master/src/index.js\n    https://github.com/gre/bezier-easing/blob/master/LICENSE\n    \n    I've removed the newtonRaphsonIterate algo because in benchmarking it\n    wasn't noticiably faster than binarySubdivision, indeed removing it\n    usually improved times, depending on the curve.\n  \n    I also removed the lookup table, as for the added bundle size and loop we're\n    only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n    to 12 to compensate and this still tended to be faster for no perceivable\n    loss in accuracy.\n  \n    Usage\n      const easeOut = cubicBezier(.17,.67,.83,.67);\n      const x = easeOut(0.5); // returns 0.627...\n  */\n  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n  const calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\n  const subdivisionPrecision = 0.0000001;\n  const subdivisionMaxIterations = 12;\n  function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n      currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - x;\n      if (currentX > 0.0) {\n        upperBound = currentT;\n      } else {\n        lowerBound = currentT;\n      }\n    } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n    return currentT;\n  }\n  function cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2) return _motiononeUtils.noopReturn;\n    const getTForX = aX => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n  }\n});","lineCount":60,"map":[[7,2,53,0,"Object"],[7,8,53,0],[7,9,53,0,"defineProperty"],[7,23,53,0],[7,24,53,0,"exports"],[7,31,53,0],[8,4,53,0,"enumerable"],[8,14,53,0],[9,4,53,0,"get"],[9,7,53,0],[9,18,53,0,"get"],[9,19,53,0],[10,6,53,0],[10,13,53,9,"cubicBezier"],[10,24,53,20],[11,4,53,20],[12,2,53,20],[13,2,1,0],[13,6,1,0,"_motiononeUtils"],[13,21,1,0],[13,24,1,0,"require"],[13,31,1,0],[13,32,1,0,"_dependencyMap"],[13,46,1,0],[14,2,3,0],[15,0,4,0],[16,0,5,0],[17,0,6,0],[18,0,7,0],[19,0,8,0],[20,0,9,0],[21,0,10,0],[22,0,11,0],[23,0,12,0],[24,0,13,0],[25,0,14,0],[26,0,15,0],[27,0,16,0],[28,0,17,0],[29,0,18,0],[30,0,19,0],[31,0,20,0],[32,0,21,0],[33,0,22,0],[34,2,23,0],[35,2,24,0],[35,8,24,6,"calcBezier"],[35,18,24,16],[35,21,24,19,"calcBezier"],[35,22,24,20,"t"],[35,23,24,21],[35,25,24,23,"a1"],[35,27,24,25],[35,29,24,27,"a2"],[35,31,24,29],[35,36,24,34],[35,37,24,35],[35,38,24,36],[35,39,24,37],[35,42,24,40],[35,45,24,43],[35,48,24,46],[35,51,24,49,"a2"],[35,53,24,51],[35,56,24,54],[35,59,24,57],[35,62,24,60,"a1"],[35,64,24,62],[35,68,24,66,"t"],[35,69,24,67],[35,73,24,71],[35,76,24,74],[35,79,24,77,"a2"],[35,81,24,79],[35,84,24,82],[35,87,24,85],[35,90,24,88,"a1"],[35,92,24,90],[35,93,24,91],[35,97,24,95,"t"],[35,98,24,96],[35,101,24,99],[35,104,24,102],[35,107,24,105,"a1"],[35,109,24,107],[35,113,24,111,"t"],[35,114,24,112],[36,2,25,0],[36,8,25,6,"subdivisionPrecision"],[36,28,25,26],[36,31,25,29],[36,40,25,38],[37,2,26,0],[37,8,26,6,"subdivisionMaxIterations"],[37,32,26,30],[37,35,26,33],[37,37,26,35],[38,2,27,0],[38,11,27,9,"binarySubdivide"],[38,26,27,24,"binarySubdivide"],[38,27,27,25,"x"],[38,28,27,26],[38,30,27,28,"lowerBound"],[38,40,27,38],[38,42,27,40,"upperBound"],[38,52,27,50],[38,54,27,52,"mX1"],[38,57,27,55],[38,59,27,57,"mX2"],[38,62,27,60],[38,64,27,62],[39,4,28,4],[39,8,28,8,"currentX"],[39,16,28,16],[40,4,29,4],[40,8,29,8,"currentT"],[40,16,29,16],[41,4,30,4],[41,8,30,8,"i"],[41,9,30,9],[41,12,30,12],[41,13,30,13],[42,4,31,4],[42,7,31,7],[43,6,32,8,"currentT"],[43,14,32,16],[43,17,32,19,"lowerBound"],[43,27,32,29],[43,30,32,32],[43,31,32,33,"upperBound"],[43,41,32,43],[43,44,32,46,"lowerBound"],[43,54,32,56],[43,58,32,60],[43,61,32,63],[44,6,33,8,"currentX"],[44,14,33,16],[44,17,33,19,"calcBezier"],[44,27,33,29],[44,28,33,30,"currentT"],[44,36,33,38],[44,38,33,40,"mX1"],[44,41,33,43],[44,43,33,45,"mX2"],[44,46,33,48],[44,47,33,49],[44,50,33,52,"x"],[44,51,33,53],[45,6,34,8],[45,10,34,12,"currentX"],[45,18,34,20],[45,21,34,23],[45,24,34,26],[45,26,34,28],[46,8,35,12,"upperBound"],[46,18,35,22],[46,21,35,25,"currentT"],[46,29,35,33],[47,6,36,8],[47,7,36,9],[47,13,37,13],[48,8,38,12,"lowerBound"],[48,18,38,22],[48,21,38,25,"currentT"],[48,29,38,33],[49,6,39,8],[50,4,40,4],[50,5,40,5],[50,13,40,13,"Math"],[50,17,40,17],[50,18,40,18,"abs"],[50,21,40,21],[50,22,40,22,"currentX"],[50,30,40,30],[50,31,40,31],[50,34,40,34,"subdivisionPrecision"],[50,54,40,54],[50,58,41,8],[50,60,41,10,"i"],[50,61,41,11],[50,64,41,14,"subdivisionMaxIterations"],[50,88,41,38],[51,4,42,4],[51,11,42,11,"currentT"],[51,19,42,19],[52,2,43,0],[53,2,44,0],[53,11,44,9,"cubicBezier"],[53,22,44,20,"cubicBezier"],[53,23,44,21,"mX1"],[53,26,44,24],[53,28,44,26,"mY1"],[53,31,44,29],[53,33,44,31,"mX2"],[53,36,44,34],[53,38,44,36,"mY2"],[53,41,44,39],[53,43,44,41],[54,4,45,4],[55,4,46,4],[55,8,46,8,"mX1"],[55,11,46,11],[55,16,46,16,"mY1"],[55,19,46,19],[55,23,46,23,"mX2"],[55,26,46,26],[55,31,46,31,"mY2"],[55,34,46,34],[55,36,47,8],[55,43,47,15,"noopReturn"],[55,58,47,25],[55,59,47,25,"noopReturn"],[55,69,47,25],[56,4,48,4],[56,10,48,10,"getTForX"],[56,18,48,18],[56,21,48,22,"aX"],[56,23,48,24],[56,27,48,29,"binarySubdivide"],[56,42,48,44],[56,43,48,45,"aX"],[56,45,48,47],[56,47,48,49],[56,48,48,50],[56,50,48,52],[56,51,48,53],[56,53,48,55,"mX1"],[56,56,48,58],[56,58,48,60,"mX2"],[56,61,48,63],[56,62,48,64],[57,4,49,4],[58,4,50,4],[58,11,50,12,"t"],[58,12,50,13],[58,16,50,18,"t"],[58,17,50,19],[58,22,50,24],[58,23,50,25],[58,27,50,29,"t"],[58,28,50,30],[58,33,50,35],[58,34,50,36],[58,37,50,39,"t"],[58,38,50,40],[58,41,50,43,"calcBezier"],[58,51,50,53],[58,52,50,54,"getTForX"],[58,60,50,62],[58,61,50,63,"t"],[58,62,50,64],[58,63,50,65],[58,65,50,67,"mY1"],[58,68,50,70],[58,70,50,72,"mY2"],[58,73,50,75],[58,74,50,76],[59,2,51,0],[60,0,51,1],[60,3]],"functionMap":{"names":["<global>","calcBezier","binarySubdivide","cubicBezier","getTForX","<anonymous>"],"mappings":"AAA;mBCuB,6FD;AEG;CFgB;AGC;qBCI,2CD;WEE,iEF;CHC"},"hasCjsExports":false},"type":"js/module"}]}