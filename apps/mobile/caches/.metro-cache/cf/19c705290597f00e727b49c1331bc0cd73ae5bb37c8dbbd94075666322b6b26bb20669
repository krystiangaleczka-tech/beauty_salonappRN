{"dependencies":[{"name":"@motionone/utils","data":{"asyncType":null,"isESMImport":false,"locs":[{"start":{"line":3,"column":12,"index":27},"end":{"line":3,"column":39,"index":54}}],"key":"FS/MZgsOo2zLy6PbOiduH8x3eaQ=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  'use strict';\n\n  var utils = require(_dependencyMap[0], \"@motionone/utils\");\n\n  /*\n    Bezier function generator\n  \n    This has been modified from GaÃ«tan Renaudeau's BezierEasing\n    https://github.com/gre/bezier-easing/blob/master/src/index.js\n    https://github.com/gre/bezier-easing/blob/master/LICENSE\n    \n    I've removed the newtonRaphsonIterate algo because in benchmarking it\n    wasn't noticiably faster than binarySubdivision, indeed removing it\n    usually improved times, depending on the curve.\n  \n    I also removed the lookup table, as for the added bundle size and loop we're\n    only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n    to 12 to compensate and this still tended to be faster for no perceivable\n    loss in accuracy.\n  \n    Usage\n      const easeOut = cubicBezier(.17,.67,.83,.67);\n      const x = easeOut(0.5); // returns 0.627...\n  */\n  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n  var calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\n  var subdivisionPrecision = 0.0000001;\n  var subdivisionMaxIterations = 12;\n  function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    var currentX;\n    var currentT;\n    var i = 0;\n    do {\n      currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - x;\n      if (currentX > 0.0) {\n        upperBound = currentT;\n      } else {\n        lowerBound = currentT;\n      }\n    } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n    return currentT;\n  }\n  function cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2) return utils.noopReturn;\n    var getTForX = aX => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n  }\n  exports.cubicBezier = cubicBezier;\n});","lineCount":53,"map":[[2,2,1,0],[2,14,1,12],[4,2,3,0],[4,6,3,4,"utils"],[4,11,3,9],[4,14,3,12,"require"],[4,21,3,19],[4,22,3,19,"_dependencyMap"],[4,36,3,19],[4,59,3,38],[4,60,3,39],[6,2,5,0],[7,0,6,0],[8,0,7,0],[9,0,8,0],[10,0,9,0],[11,0,10,0],[12,0,11,0],[13,0,12,0],[14,0,13,0],[15,0,14,0],[16,0,15,0],[17,0,16,0],[18,0,17,0],[19,0,18,0],[20,0,19,0],[21,0,20,0],[22,0,21,0],[23,0,22,0],[24,0,23,0],[25,0,24,0],[26,2,25,0],[27,2,26,0],[27,6,26,6,"calcBezier"],[27,16,26,16],[27,19,26,19,"calcBezier"],[27,20,26,20,"t"],[27,21,26,21],[27,23,26,23,"a1"],[27,25,26,25],[27,27,26,27,"a2"],[27,29,26,29],[27,34,26,34],[27,35,26,35],[27,36,26,36],[27,37,26,37],[27,40,26,40],[27,43,26,43],[27,46,26,46],[27,49,26,49,"a2"],[27,51,26,51],[27,54,26,54],[27,57,26,57],[27,60,26,60,"a1"],[27,62,26,62],[27,66,26,66,"t"],[27,67,26,67],[27,71,26,71],[27,74,26,74],[27,77,26,77,"a2"],[27,79,26,79],[27,82,26,82],[27,85,26,85],[27,88,26,88,"a1"],[27,90,26,90],[27,91,26,91],[27,95,26,95,"t"],[27,96,26,96],[27,99,26,99],[27,102,26,102],[27,105,26,105,"a1"],[27,107,26,107],[27,111,26,111,"t"],[27,112,26,112],[28,2,27,0],[28,6,27,6,"subdivisionPrecision"],[28,26,27,26],[28,29,27,29],[28,38,27,38],[29,2,28,0],[29,6,28,6,"subdivisionMaxIterations"],[29,30,28,30],[29,33,28,33],[29,35,28,35],[30,2,29,0],[30,11,29,9,"binarySubdivide"],[30,26,29,24,"binarySubdivide"],[30,27,29,25,"x"],[30,28,29,26],[30,30,29,28,"lowerBound"],[30,40,29,38],[30,42,29,40,"upperBound"],[30,52,29,50],[30,54,29,52,"mX1"],[30,57,29,55],[30,59,29,57,"mX2"],[30,62,29,60],[30,64,29,62],[31,4,30,4],[31,8,30,8,"currentX"],[31,16,30,16],[32,4,31,4],[32,8,31,8,"currentT"],[32,16,31,16],[33,4,32,4],[33,8,32,8,"i"],[33,9,32,9],[33,12,32,12],[33,13,32,13],[34,4,33,4],[34,7,33,7],[35,6,34,8,"currentT"],[35,14,34,16],[35,17,34,19,"lowerBound"],[35,27,34,29],[35,30,34,32],[35,31,34,33,"upperBound"],[35,41,34,43],[35,44,34,46,"lowerBound"],[35,54,34,56],[35,58,34,60],[35,61,34,63],[36,6,35,8,"currentX"],[36,14,35,16],[36,17,35,19,"calcBezier"],[36,27,35,29],[36,28,35,30,"currentT"],[36,36,35,38],[36,38,35,40,"mX1"],[36,41,35,43],[36,43,35,45,"mX2"],[36,46,35,48],[36,47,35,49],[36,50,35,52,"x"],[36,51,35,53],[37,6,36,8],[37,10,36,12,"currentX"],[37,18,36,20],[37,21,36,23],[37,24,36,26],[37,26,36,28],[38,8,37,12,"upperBound"],[38,18,37,22],[38,21,37,25,"currentT"],[38,29,37,33],[39,6,38,8],[39,7,38,9],[39,13,39,13],[40,8,40,12,"lowerBound"],[40,18,40,22],[40,21,40,25,"currentT"],[40,29,40,33],[41,6,41,8],[42,4,42,4],[42,5,42,5],[42,13,42,13,"Math"],[42,17,42,17],[42,18,42,18,"abs"],[42,21,42,21],[42,22,42,22,"currentX"],[42,30,42,30],[42,31,42,31],[42,34,42,34,"subdivisionPrecision"],[42,54,42,54],[42,58,43,8],[42,60,43,10,"i"],[42,61,43,11],[42,64,43,14,"subdivisionMaxIterations"],[42,88,43,38],[43,4,44,4],[43,11,44,11,"currentT"],[43,19,44,19],[44,2,45,0],[45,2,46,0],[45,11,46,9,"cubicBezier"],[45,22,46,20,"cubicBezier"],[45,23,46,21,"mX1"],[45,26,46,24],[45,28,46,26,"mY1"],[45,31,46,29],[45,33,46,31,"mX2"],[45,36,46,34],[45,38,46,36,"mY2"],[45,41,46,39],[45,43,46,41],[46,4,47,4],[47,4,48,4],[47,8,48,8,"mX1"],[47,11,48,11],[47,16,48,16,"mY1"],[47,19,48,19],[47,23,48,23,"mX2"],[47,26,48,26],[47,31,48,31,"mY2"],[47,34,48,34],[47,36,49,8],[47,43,49,15,"utils"],[47,48,49,20],[47,49,49,21,"noopReturn"],[47,59,49,31],[48,4,50,4],[48,8,50,10,"getTForX"],[48,16,50,18],[48,19,50,22,"aX"],[48,21,50,24],[48,25,50,29,"binarySubdivide"],[48,40,50,44],[48,41,50,45,"aX"],[48,43,50,47],[48,45,50,49],[48,46,50,50],[48,48,50,52],[48,49,50,53],[48,51,50,55,"mX1"],[48,54,50,58],[48,56,50,60,"mX2"],[48,59,50,63],[48,60,50,64],[49,4,51,4],[50,4,52,4],[50,11,52,12,"t"],[50,12,52,13],[50,16,52,18,"t"],[50,17,52,19],[50,22,52,24],[50,23,52,25],[50,27,52,29,"t"],[50,28,52,30],[50,33,52,35],[50,34,52,36],[50,37,52,39,"t"],[50,38,52,40],[50,41,52,43,"calcBezier"],[50,51,52,53],[50,52,52,54,"getTForX"],[50,60,52,62],[50,61,52,63,"t"],[50,62,52,64],[50,63,52,65],[50,65,52,67,"mY1"],[50,68,52,70],[50,70,52,72,"mY2"],[50,73,52,75],[50,74,52,76],[51,2,53,0],[52,2,55,0,"exports"],[52,9,55,7],[52,10,55,8,"cubicBezier"],[52,21,55,19],[52,24,55,22,"cubicBezier"],[52,35,55,33],[53,0,55,34],[53,3]],"functionMap":{"names":["<global>","calcBezier","binarySubdivide","cubicBezier","getTForX","<anonymous>"],"mappings":"AAA;mBCyB,6FD;AEG;CFgB;AGC;qBCI,2CD;WEE,iEF;CHC"},"hasCjsExports":true},"type":"js/module"}]}